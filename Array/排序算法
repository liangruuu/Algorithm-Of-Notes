O(n)
选择排序，插入排序，希尔排序，冒泡排序

1. 选择排序是插入排序的差别是，不管整个数组序列如何，前者都需要遍历当前操作元素之后的元素(两层循环，每层循环都必须得完全执行)选择之后序列中最小(大)的元素，但是插入排序可以随时终止(arr[j] > arr[j - 1])，不需要遍历当前元素之前的元素，只要遇到比当前元素小(大)的元素可以break循环，所以理论上插入排序要比选择排序效率高
	* 但是问题在于swap()函数是要比普通的比较函数都要耗时的(三个赋值操作), 
		如果数组序列是一个近乎于完全有序(大->小, 小<-大)的，那么插入排序就要进行n - 1次交换
	* 改进方法就是选定一个arr[j]时不贸然和arr[j - 1]进行swap操作, 先给这个arr[j]复制一个副本(T e = arr[i]), 
		再观察这个值是否应该存在于这个位置上, 比如arr[j] = 2, arr[j - 1] = 8(以小->大排序为例), 则2不应该待在arr[j]这个位置, 
		则数字8后移一位(arr[j] = arr[j - 1]), 循环往复直到循环break或者结束(j保存元素e应该插入的位置)
	* 把一次又一次的swap操作(三次赋值)换成了比较后做一次赋值
	* 插入排序能引申出一种重要的排序算法(希尔排序), 插入排序每次尝试和当前元素之前的一个元素比较, 希尔排序和当前元素之前第H个元素比较,
		在这个过程中H会从一个很大的值逐渐缩小成1, 把一个近乎无序的数组变为一个有序的数组, 当H=1时就变为了一个排好序的数组
2. 插入排序是从i=1，j=i开始循环，遍历条件为i<n;j>0(当前元素和之前元素的比较);选择排序是从i=0, j=i+1开始循环,遍历条件为i<n-1;j<n
3. 插入排序对近乎有序的序列的排序效率比一些复杂度为O(nlogn)的算法效率还要高(比如说对日志的排序, 因为日志就是根据时间戳来生成的, 			可能存在几个无序的日志), 插入排序会在更加复杂的排序算法中充当子过程来进行优化

----------------------------------
O(nlogn)
归并排序, 快速排序

1. 归并排序(8 6 2 3 1 5 7 4):
首先把数组分成一半, 然后想办法把左边和右边的数组分别排序然后再归并到一起, 以此类推(递归), 到最后一级(一共3级)时每一个部分就只剩下一个元素了(log28 = 3, 二分法), 即分层需要O(logn)的复杂度, 如果我们能设计出一个归并过程复杂度为O(n)的算法，那么整个归并排序的复杂度就为O(NlogN)
	* 递归的逻辑： 数组分成两部分，每部分别排好序，使用O(N)的算法归并到一起
	1) 把两个排好序的数组合并成一个数组(需要开辟额外的空间)：
		k->*2 3 6 8 1 4 5 7
		i->*2 3 6 8 | j->*1 4 5 7    <---(额外空间)
		* 使用三个索引(i,j,k):下方两个有序数组当前考虑的元素下标为i, j;	k代表两个元素比较之后应该放到的归并数组内的下标，不代表归并结束后已经放置的最后一个元素的位置
		* 在数组里进行追踪(因为是要把两个数组归并在一起的, 所以两个数组内的头部元素是要进行比较的，来比出到底谁更小，然后放到最终数组的起始位置)
		* 同时需要对越界情况进行标记(l(left), m(middle), r(right))

		1 *3 6 8 1 4 5 7
		*2 3 6 8 | 1 *4 5 7
		---------------------
		1 2 *6 8 1 4 5 7
		2 *3 6 8 | 1 *4 5 7
		以此类推......

	2) * 一般写递归函数的时候需要写一个总函数和一个递归函数，总函数调用递归函数
		例如在java里，需要定义一个public总函数和一个private递归函数，然后在public总函数中调用private递归函数
		总函数是对用户是可见的，具体表现为形式参数不涉及到具体算法，比如只传递一个数组，数组的长度...
		而递归函数的参数是需要涉及到具体算法的，是对用户不可见的，比如左边界下标，右边界下标

		template <typename T> void mergeSort(T arr[], int n) {
  			__mergeSort(arr, 0, n - 1);
		}

		template <typename T> void __mergeSort(T arr[], int l, int r) {
		  	// 终止条件
		  	if (l >= r)
		    	return;

		  	int mid = (l + r) / 2;
		  	// 排左边
		  	__mergeSort(arr, l, mid);
		  	// 排右边
		  	__mergeSort(arr, mid + 1, r);
		  	// 将arr[l...mid]和arr[mid+1...r]两部分进行归并
			__merge(arr, l, mid, r);
		}

		template <typename T> void __merge(T arr[], int l, int mid, int r) {
		  	T aux[r - l + 1];
		 	for (int i = l; i <= r; i++)
		   	 	aux[i - l] = arr[i];

		  	// 初始化，i指向左半部分的起始索引位置l；j指向右半部分起始索引位置mid+1
		  	int i = l, j = mid + 1;
		  	for (int k = l; k <= r; k++) {
			    if (i > mid) { // 如果左半部分元素已经全部处理完毕
			      	arr[k] = aux[j - l];
			      	j++;
			    } else if (j > r) { // 如果右半部分元素已经全部处理完毕
			      	arr[k] = aux[i - l];
			      	i++;
			    } else if (aux[i - l] < aux[j - l]) { // 左半部分所指元素 < 右半部分所指元素
			      	arr[k] = aux[i - l];
			      	i++;
			    } else { // 左半部分所指元素 >= 右半部分所指元素
			      	arr[k] = aux[j - l];
			      	j++;
			    }
		  	}
		}

	3) 	优化一： 对于arr[mid] <= arr[mid+1]的情况,不进行merge
		// 对于近乎有序的数组非常有效,但是对于一般情况,有一定的性能损失
	 	if (arr[mid] > arr[mid + 1])
			__merge(arr, l, mid, r);

		优化二： 对于小规模数组, 使用插入排序(递归结束条件0), 因为对于小规模数据而言有序的概率会很大
	  	if (r - l <= 15) {
	    	insertionSort(arr, l, r);
	    	return;
	  	}

	4) 自底向上归并排序(8 6 2 3 1 5 7 4):
		从左到右依次把数组划分成若干个小段, 然后再进行归并排序的过程
		8 | 6 | 2 | 3 | 1 | 5 | 7 | 4
		--------------------
		8 6 | 2 3 | 1 5 | 7 4
		--------------------
		6 8 | 2 3 | 1 5 | 4 7
		--------------------
		6 8 2 3 | 1 5 4 7
		--------------------
		2 3 6 8 | 1 4 5 7
		--------------------
		1 2 3 4 5 6 7 8
		在整个过程中不需要递归只需要迭代就可以完成归并排序

		// 使用自底向上的归并排序算法
		// 第一层循环是对进行merge的元素个数进行遍历1-2-4-8-...
		// 第二层循环具体每一轮在归并的过程中起始的元素位置, 每次循环平移两个sz, 例：
			6 8 | 2 3 | 1 5 | 4 7
			---------------------
			6 8 2 3 | 1 5 4 7
		sz = 2, i的下标从0->4, 即i += (2 + 2)
		每次循环归并都是0~sz-1, sz~2sz-1, 2sz~3sz-1....
		// 而且需要保证越界问题，归并操作需要两个归并部分都存在才有意义，所以需要保证i + sz < n
		// 此情况下右侧的归并部分可能长度并不是一半(不足sz), 即i+2sz-1可能会越界，所以取它和下标n-1的最小值, 但是merge操作跟归并部分的长度无关

		template <typename T> void mergeSortBU(T arr[], int n) {
	    	for( int sz = 1; sz <= n ; sz += sz )
	         	for( int i = 0 ; i + sz < n ; i += sz+sz )
	            	// 对 arr[i...i+sz-1] 和 arr[i+sz...i+2*sz-1] 进行归并
	            	__merge(arr, i, i+sz-1, min(i+sz+sz-1,n-1) );
		}

	5) 因为不涉及到对数组下标的调用(即通过数组下标获取元素), 所以自底向上归并排序可以用O(nlogn)的复杂度对链表这样的数据结构进行排序

2. 快速排序：(4 6 2 3 1 5 7 8)
	归并排序是不管数组的内容是什么，直接将整个数组一分为二之后再通过归并对数组进行排序, 而快速排序则每次从当前考虑的数组中选择一个元素, 以这个元素为基点
	比如把(4 6 2 3 1 5 7 8)中的4放到排好序之后所处的位置(6 2 3 4 1 5 7 8), 在此情况下整个数组就有了一个性质, 在4左侧的元素都比4小, 在4右侧的元素都比4大.
	此时对4右侧和左侧的数组分别使用快速排序...逐渐递归完成排序
	* 快速排序的关键是如何把4这个基点元素挪到正确的位置上(Partition)
	1. 使用数组的第一个元素作为分界的标志点l(left), arr[l]=v, 之后再逐渐遍历右侧没有被访问的元素, 在便利的过程中逐渐整理整个数组,让整个数组一部分小于v
		另外一部分的元素是大于v的, 需要记录大于小于v的分界点j, 当前访问元素的节点下标为i, arr[i] = e
		arr[l+1....j] < v   arr[j+1...i-1] > v
		(v) (<v) (>v) e
		 l      j     i

	2. 讨论i这个位置, 当前的元素到底要怎样变化才能保证数组还有这样的性质
		1) 若e>v, 直接把下标为i的元素放入数组>v的部分, 然后i后移讨论之后的元素
			arr[l+1....j] < v   arr[j+1...i-1] > v
			(v) (<v) (>v e) 
			 l      j      i
		
		2) 若e<v, 把j所指的后面一个元素和当前所考察的i所指元素e交换位置, 然后j后移
			arr[l+1....j] < v   arr[j+1...i-1] > v
			(v) (<v e) (>v x) 
			 l        j      i

		3) 交换l,j的元素
		 	arr[l+1....j] < v   arr[j+1...i-1] > v
			(<v e)(v)(>v ) 
			 l     j      i

	3. 归并排序可以保证每次都是平局的将整个数组一分为二，但是快速排序却没有整个保证，导致分出来了两个子数组可能是极度不平衡的
		最差的情况整个数组近乎有序复杂度退化为O(n^2), 现在是固定的选定最左侧元素作为标定点, 然而我们希望的是尽可能选择整个数组中间的元素作为标定元素, 
		我们只要随机选择一个元素, 数学上证明此时快速排序的时间复杂度期望值是O(NlogN)
		
		template <typename T> int _partition(T arr[], int l, int r) {
		  	// 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot
		  	swap(arr[l], arr[rand() % (r - l + 1) + l]);

		  	T v = arr[l];
		  	int j = l;
		  	for (int i = l + 1; i <= r; i++)
		    	if (arr[i] < v) {
		      		j++;
		      		swap(arr[j], arr[i]);
		    	}

		  	swap(arr[l], arr[j]);

		  	return j;
		}

	4. 如果原数组中有大量相等的元素(使用二路归并排序)
		(v)(<v)(>=v) 或者 (v)(<=v)(>v)也会造成极度不平衡的情况出现,复杂度会退化成O(n^2)

3. 索引堆：
	问题背景：堆排序有个蛮致命的问题就是，每个元素在数组中的位置发生了改变使得当我们的堆建成以后很难索引到它，当我们难以索引到它时我们就很难去改变它
	比如说，这些数组元素索引代表的是一个个系统进程id号，元素代表进程对应的优先级，当进行堆排序时进程ID就无法和优先级对应起来

	1) 将数据和索引分开存储，而表示堆的数据是由索引构建而成，比较的是元素数据，交换的是元素索引