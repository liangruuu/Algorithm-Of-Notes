1. Fibonacci问题  

版本一
```
// 递归求斐波那契数列
int fib(int n) {

  num++;

  if (n == 0)
    return 0;

  if (n == 1)
    return 1;

  return fib(n - 1) + fib(n - 2);
}
```
版本一存在着很大的问题,若按照版本一的代码则会重复执行多次Fibonacci函数  
```
例：
Fibonacci(5) = Fibonacci(4) + Fibonacci(3) 
Fibonacci(4) = Fibonacci(3) + Fibonacci(2)   Fibonacci(3)重复计算
Fibonacci(3) = Fibonacci(2) + Fibonacci(1)   Fibonacci(2)重复计算
...
```
版本二
```
vector<int> memo;
int num = 0;

// 记忆化搜索, 自下而上解决问题
int fib(int n) {

  num++;

  if (n == 0)
    return 0;

  if (n == 1)
    return 1;
  
  // 为了不重复执行fib()函数
  if (memo[n] == -1)
    memo[n] = fib(n - 1) + fib(n - 2);

  return memo[n];
}

memo = vector<int>(n + 1, -1);
``` 
版本三
```
// 动态规划, 自下而上解决问题(先解决小数据量问题的结果,再层层递推大数据量的结果)
int fib(int n) {

  vector<int> memo(n + 1, -1);

  memo[0] = 0;
  memo[1] = 1;
  for (int i = 2; i <= n; i++)
    memo[i] = memo[i - 1] + memo[i - 2];

  return memo[n];
}
```

## 动态规划
将原问题拆解成若干子问题, 同时保存子问题的答案, 使得每个子问题只求解一次, 最终获得原问题的答案
```

                    ————记忆化搜索(自顶向下的解决问题)
递归问题——>重叠子问题      ↓
                    ————动态规划(自底向上的解决问题)
```
