1. Fibonacci问题  

版本一
```
// 递归求斐波那契数列
int fib(int n) {

  num++;

  if (n == 0)
    return 0;

  if (n == 1)
    return 1;

  return fib(n - 1) + fib(n - 2);
}
```
版本一存在着很大的问题,若按照版本一的代码则会重复执行多次Fibonacci函数  
```
例：
Fibonacci(5) = Fibonacci(4) + Fibonacci(3) 
Fibonacci(4) = Fibonacci(3) + Fibonacci(2)   Fibonacci(3)重复计算
Fibonacci(3) = Fibonacci(2) + Fibonacci(1)   Fibonacci(2)重复计算
...
```
版本二
```
vector<int> memo;
int num = 0;

// 记忆化搜索, 自下而上解决问题
int fib(int n) {

  num++;

  if (n == 0)
    return 0;

  if (n == 1)
    return 1;
  
  // 为了不重复执行fib()函数
  if (memo[n] == -1)
    memo[n] = fib(n - 1) + fib(n - 2);

  return memo[n];
}

memo = vector<int>(n + 1, -1);
``` 
版本三
```
// 动态规划, 自下而上解决问题(先解决小数据量问题的结果,再层层递推大数据量的结果)
int fib(int n) {

  vector<int> memo(n + 1, -1);

  memo[0] = 0;
  memo[1] = 1;
  for (int i = 2; i <= n; i++)
    memo[i] = memo[i - 1] + memo[i - 2];

  return memo[n];
}
```

## 动态规划
将原问题拆解成若干子问题, 同时保存子问题的答案, 使得每个子问题只求解一次, 最终获得原问题的答案  
```
由数组构成(dp或者memo)
使用动态规划前首先明确四点(关键)
1. dp[i]是干什么的(i需要用循环来实现，即动态规划必然使用到循环)
  * 表示考虑抢劫nums[i..n)所能获得的最大收益
  * 表示分割数i所能得到的乘积最大值
  * 表示爬上第i层可以有几种方式
2. 最小集合是什么(对应递归方式的递归终止条件)
  * 最小集合时, i == n - 1(dp[n - 1] = nums[n - 1](盗取第n-1个房间)
  * 最小集合时, i == 1(dp[1] == 1)(分割整数1)
  * 最小集合时, i == 1(dp[1] == 1)(爬上第一阶台阶)
3. 返回值是什么
  * dp[0]
  * dp[n]
  * dp[n]
4. 每个循环的逻辑(具体问题具体分析)
```

最优子结构：
通过求子问题的最优解, 可以获得原问题的最优解
```

                    ————记忆化搜索(自顶向下的解决问题)
递归问题——>重叠子问题      ↓
          最优子结构       
                    ————动态规划(自底向上的解决问题)
```
1. 0-1背包问题  
有一个背包, 它的容量为C. 现有n个不同的物品(编号0..n-1),其中每一件物品的重量为w(i), 价值为v(i). 问怎么放不超过背包容量使得物品总价值最大.  
(416. Partition Equal Subset Sum)
* 暴力解法：每一件物品都可以放进背包,也可以不放进背包(O((2^n)*n)), 放进背包不放进背包两个状态2^n, 遍历每一件物品n的重量
* 考虑状态(状态方程的参数表示有几个约束条件)  
F(n, C) = **考虑** 将n个物品放入容量为C的背包,使得价值最大(两个约束条件)
  - 状态转移  
    F(i, c) = F(i-1, c) 对第i个物品不管,即虽然来了一个新的物品但是不放入背包  
    = v(i) + F(i-1, c-w(i)) 把第i个物品放入背包  
    在这两种选择中选择一个最大值max
  - 状态转移方程F(i, C) = max(F(i-1, c), v(i)+F(i-1, c-w(i)))  

2. 0-1背包问题更多变种
  * 完全背包问题：每个物品可以无限使用(虽然每个物品可以无限使用, 但是由于背包的容量是有限的,所以其实每个物品可以取到的个数是有限的, 即可以转换成有限使用的0-1背包问题,只不过有些物品会重复)
  * 多重背包问题：每个物品不止1个, 有num(i)个
  * 多维费用的背包问题:要考虑物品的体积和重量两个维度(三维数组)
  * 物品间加入更多约束(排除,依赖)

3. 最长上升子序列  
(300. Longest Increasing Subsequence)  
(376. Wiggle Subsequence)

4. 最长公共子序列(LCS): 给出两个字符串S1,S2, 求这两个字符串的最长公共子序列的长度  
基因工程(一串基因只有ACGT四个字母)：  
衡量两个基因的相似度有个衡量标准就是看两个基因最长公共子序列的长度,长度越高越相似
```
S1=AA[ACC]G[T]G[AG]T[TA]TT[C]G[TT]CTA[G]AA
S2=C[A]CC[CCTA]AG[GTAC]C[TTTG]GTTC
```
两个维度进行动态规划, 因为要在两个字符串中进行扫描  
状态：F(x,y) = LCS(m,n) = S1[0..m]和S2[0..n]的最长公共子序列的长度  
状态转移方程：  
S1[m] == S2[n];  
LCS(m,n) = 1 + LCS(m-1, n-1)  
S1[m] != S2[n];  
LCS(m,n) = max( LCS(m-1, n), LCS(m, n-1) )
```
            ABC[D]|AEB[D]
                 1|
             AB[C]|AE[B]
          /               \
      A[B]|AE[B]      AB[C]|A[E]
         1|             /         \
       [A]|A[E]       A[B]|A[E]   AB[C]|[A]
      /       \       /       \           \...
     -|AE   [A]|[A]  [A]|A[E] A[B]|[A]
              1|        ...
              -|-
```

5. dijkstra单源最短路径算法也是动态规划  
状态转移方程：  
shortestPath(i)为从start到i的最短路径长度  
shortestPath(x)=min(shortPath(a)+w(a->x))