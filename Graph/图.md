1. 图基础
2. 邻接矩阵和邻接表的构建(02-Graph-Representation)
3. 创建关于图的迭代器以便于遍历整个图(03-Vertex Adjacent Iterator)
4. 测试图算法(用文件来生成测试用例): 第一行为有几个节点, 几条边; 第二行向下表示每条边的起始终止节点(04-Read-Graph)
5. 深度优先遍历和连通分量(05-DFS-and-Components)
  * 和Tree的深度优先遍历基本一样, 对于树向下走一定有走不通的时候, 但是图是一个环, 对此我们需要记录一个点是否被遍历过了(visited[i])
  * 联通分量之间是不相连的
  * 复杂度：稀疏图(O(V+E)), 稠密图(O(V^2))
6. 寻路(相较于并查集只能判断两节点是否相连接,图而且能找出两点之间的路径)(06-Finding-a-Path)
7. 广度优先遍历和最短路径(07-BFS-and-Shortest-Path)
* 广度优先遍历求出了无权图的最短路径
8. 有权图(01-Weighted-Graph)
  * 定义一个Edge类用来存储边的权重和终止端点
  * 在邻接矩阵中, 数值为0的节点意思为空;所以存储Edge类型的指针(*Edge), 数值为0的点表示空指针
  * 为了统一稠密图和稀疏图的实现接口, 在邻接表实现中也把Edge实现成一个指针的形式
9. 最小生成树问题
  * 横切边：如果一个边的两个端点，属于切分不同的两边，这个边成为横切边
  * 切分定理：给定任意切分，横切边中权值最小的边必然属于最小生成树
  * Lazy Prim(03-Lazy-Prim)：用最小堆实现Lazy Prim算法
  * Lazy Prim的优化(05-Implementation-of-Optimized-Prim-Algorithm)
    * Lazy Prim主要问题在于所有的边都要进入最小堆,虽然随着我们切分的改变, 红色的节点越来越多,很多在最小堆中的边其实已经不是横切边了
    * 虽然有很多横切边, 但是我们通常只关注权值最小的那个横切边, 尤其和一个节点相邻的横切边在这种情况下其实只需要考虑和这个节点相邻的权值最小的横切边就够了
    * 基于上面的想法, 现在想维护一个数据结构保存"和每个节点相连的那个最小的横切边", 在我们不断扩大红色节点改变切分这个过程中,我们只需要不断更新和每个节点相连的最小的横切边就够了(使用IndexMinHeap:索引堆)
  * Kruskal算法(06-Kruskal-Algorithm)(O(ElogE))
    * 先对所有边进行排序
    * 使用并查集查看两个顶点是否有同一个父节点,若是则形成环

10. 图中最短路径问题(对无向图和有向图均成立)
  * 最短路径树
  * 单源最短路径：从一个点到其他所有点的最短路径, 不局限于一个点到另一个点
  * Dijktra算法