0. 递归代码的编写格式
  * 先得出递归函数的参数
  * 考虑终止条件和终止时的操作逻辑
  * 考虑本轮递归的操作是什么
  * 下次递归传递的数据
  * 要理清楚本次操作和下次递归的次序(把递归函数看成一个既定的变量)
```
翻转字符串
class Solution {
private:
  void __printReverse(const string &s, int index) {
    if (index == s.size())
      return;
    __printReverse(s, index + 1);
    cout << s[index];
  }

public:
  void printReverse(const string &s) {
    __printReverse(s, 0);
  }
};

1. 得出递归函数参数：原始字符串s, 已经处理了index个元素(还有一种解释, 即当前递归处理的元素下标)
  * 比如index == 0时表示初始递归：有0个元素被处理(当前递归处理的元素下标为0)
2. 递归终止条件为：已经有s.size()个元素通过递归操作了，没什么好做的，直接结束(return)
3. 本轮递归的操作：输出当前字符
4. 下次递归传递的数据：原始字符串s, 已经有index+1个元素经过递归了
5. 搞清楚下轮递归和本轮操作的次序(把递归函数看成一个既定的变量)：既定的变量就是下标为index后面的字符串已经反转，
  则应该为当前字符放在已经被反转的字符串后面(即先进行下一轮递归，再进行当前输出操作)
```


1. 递归调用的一个重要特征-要返回值
  * 递归调用也被称之为回溯,也就是说沿着一条路径寻找答案,一旦我们到底了的话我们就回去继续寻找一次类推
  * 递归或者回溯的时间复杂度为O(k^n)
  * 回溯法是暴力解法的一个主要实现手段
  * 使用回溯算法时, 递归函数自动保证了回去,但是我们设置的其他变量如果有必要也必须回到原样(状态回溯)

2. 注意递归终止条件  
// 112. Path Sum  
https://leetcode.com/problems/path-sum/
```
// 不注意终止条件前
class Solution {
public:
    bool hasPathSum(TreeNode* root, int sum) {
      if(root == NULL)
          return sum == 0;

      if(hasPathSum(root->left, sum - root->val))
          return true;
      if(hasPathSum(root->right, sum - root->val))
          return true;    

      return false;
    }
};
```
这题硬性规定终止节点必须为叶子节点,而上面的终止条件可以不限定为叶子结点,可以是左右节点任意是空节点的节点
```
sum = 5
 5
  \
   8
  / \
 13  4  
```
这个例子在第一个节点就终止了, 但是不符合条件  
修改后的代码硬性规定了终止节点必须为叶子节点
```
bool hasPathSum(TreeNode *root, int sum) {

    if (root == NULL)
      return false;

    if (root->left == NULL && root->right == NULL)
      return sum == root->val;

    return hasPathSum(root->left, sum - root->val) ||
           hasPathSum(root->right, sum - root->val);
  }
```

3. 回溯算法的应用
 * 排列问题(46. Permutations)
 * 组合问题(77. Combinations)
 * 二维平面上使用回溯法  
  **floodfill算法, 一类经典问题(本质问题为深度优先遍历)